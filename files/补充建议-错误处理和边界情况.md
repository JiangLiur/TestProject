# 补充建议：错误处理和边界情况

## 需要考虑的边界情况

### 1. 格式异常处理

#### 情况1：描述中没有逗号分隔符
```python
def safe_split_description(description):
    """
    安全地分割描述文本
    """
    if not description or pd.isna(description):
        return []

    # 尝试逗号分隔
    if ',' in description:
        return [p.strip() for p in description.split(',')]

    # 如果没有逗号，尝试分号
    elif ';' in description:
        logging.warning(f"使用分号分隔: {description}")
        return [p.strip() for p in description.split(';')]

    # 都没有，返回整个字符串作为单个元素
    else:
        logging.warning(f"无法分割描述，使用fallback: {description}")
        return [description]
```

#### 情况2：位置索引超出范围
```python
def safe_replace_by_position(parts, position, old_value, new_value):
    """
    安全地按位置替换
    """
    if position is None:
        return parts

    if position >= len(parts):
        logging.warning(f"位置{position}超出范围(长度:{len(parts)})")
        # 使用fallback：在整个列表中查找
        for i, part in enumerate(parts):
            if old_value in part:
                parts[i] = part.replace(old_value, new_value)
                logging.info(f"使用fallback在位置{i}替换")
                break
        return parts

    # 正常替换
    if old_value in parts[position]:
        parts[position] = parts[position].replace(old_value, new_value)

    return parts
```

### 2. 置信度不足的处理

#### 情况3：某个SHORTCODE样本太少
```python
def analyze_pcmcd_format_with_threshold(pcmcd_df, num_rows=622, min_samples=5, min_confidence=0.8):
    """
    分析格式，并标记置信度不足的管件类型
    """
    format_stats = analyze_pcmcd_format(pcmcd_df, num_rows)
    format_rules = extract_dominant_positions(format_stats)

    # 标记置信度
    for shortcode, rule in format_rules.items():
        sample_count = rule['sample_count']
        material_confidence = rule['confidence']['material']
        size_confidence = rule['confidence']['size']

        # 样本太少
        if sample_count < min_samples:
            rule['warning'] = f"样本数量不足({sample_count}个)，建议人工确认"
            rule['use_fallback'] = True

        # 置信度太低
        elif material_confidence < min_confidence or size_confidence < min_confidence:
            rule['warning'] = f"置信度较低(材料:{material_confidence:.1%}, 尺寸:{size_confidence:.1%})"
            rule['use_fallback'] = True
        else:
            rule['use_fallback'] = False

    return format_rules
```

### 3. 空值和特殊字符处理

#### 情况4：描述字段为空
```python
def intelligent_replace_safe(description, shortcode, format_rules, material_mapping, size_mapping):
    """
    增强的智能替换，处理空值和异常
    """
    # 空值检查
    if not description or pd.isna(description):
        logging.debug(f"[{shortcode}] 描述为空，跳过")
        return description

    # 去除前后空格
    description = description.strip()

    # 检查是否包含可替换内容
    has_material = any(old_mat in description for old_mat in material_mapping.keys())
    has_size = any(old_size in description for old_size in size_mapping.keys())

    if not has_material and not has_size:
        logging.debug(f"[{shortcode}] 无需替换: {description[:50]}")
        return description

    # 执行替换
    try:
        return replace_by_position(description, shortcode, format_rules, material_mapping, size_mapping)
    except Exception as e:
        logging.error(f"替换失败: {description[:50]}, 错误: {str(e)}")
        # 返回原值，不中断程序
        return description
```

### 4. 多种格式并存的处理

#### 情况5：一种管件有多种描述格式
```python
def analyze_pcmcd_format_advanced(pcmcd_df, num_rows=622):
    """
    高级格式分析，识别多种格式
    """
    from collections import Counter

    format_patterns = {}

    for index, row in pcmcd_df.head(num_rows).iterrows():
        shortcode = row.get('SHORTCODE', '')
        long_desc = row.get('LONGMATERIALDESCRIPTION', '')

        if pd.isna(long_desc):
            continue

        parts = [p.strip() for p in long_desc.split(',')]

        if shortcode not in format_patterns:
            format_patterns[shortcode] = {
                'format_signatures': [],  # 记录所有格式签名
                'material_positions': [],
                'size_positions': []
            }

        # 生成格式签名（描述各位置的类型）
        signature = []
        for i, part in enumerate(parts):
            if re.search(r'\b(ASTM|ASME|DIN)\s+[A-Z0-9\s]+', part):
                signature.append('MATERIAL')
                format_patterns[shortcode]['material_positions'].append(i)
            elif re.search(r'\b(SCH|Class|PN)', part):
                signature.append('SIZE')
                format_patterns[shortcode]['size_positions'].append(i)
            else:
                signature.append('OTHER')

        format_patterns[shortcode]['format_signatures'].append(tuple(signature))

    # 分析多种格式
    for shortcode, patterns in format_patterns.items():
        signature_counter = Counter(patterns['format_signatures'])

        if len(signature_counter) > 1:
            logging.warning(f"{shortcode}存在多种格式:")
            for sig, count in signature_counter.most_common():
                logging.warning(f"  格式: {sig}, 出现次数: {count}")

    return format_patterns
```

## 实施建议

### 优先级1：必须实现
- ✅ 空值检查和安全替换
- ✅ 位置索引边界检查
- ✅ 异常捕获和降级处理

### 优先级2：强烈推荐
- ✅ 置信度评估和警告
- ✅ 样本数量检查
- ✅ 格式异常检测

### 优先级3：可选增强
- ✅ 多格式识别和处理
- ✅ 特殊字符处理
- ✅ 自动修正建议

## 测试用例

### 测试1：空值处理
```python
test_cases = [
    None,
    "",
    "   ",
    pd.NA
]

for test in test_cases:
    result = intelligent_replace_safe(test, "Elbow", format_rules, {}, {})
    assert result is None or result == ""
```

### 测试2：格式异常
```python
abnormal_descriptions = [
    "Elbow 90° ASTM A234 WPB",  # 没有逗号
    "Elbow, 90°",  # 太短
    "Elbow, 90°, ASTM A234 WPB, Butt Weld, SCH40, ASME B16.9, Extra Info, More Info"  # 太长
]
```

### 测试3：置信度不足
```python
# 模拟只有2个样本的管件类型
rare_component_df = pcmcd_df[pcmcd_df['SHORTCODE'] == 'RareComponent']
assert len(rare_component_df) < 5
# 应该触发警告并使用fallback
```

---

**版本**: 1.0
**创建日期**: 2025-11-13
**用途**: 补充原方案中的错误处理和边界情况考虑
